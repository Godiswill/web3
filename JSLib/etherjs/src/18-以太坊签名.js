/**
 * 理解以太坊的双椭圆曲线数字签名算法（ECDSA）
 * 借用此算法，用户可以不用暴露私钥的情况下，
 * 任何第三方都可以凭借公钥确认此消息是否是该用户发出。
 * 签名消息具有身份认证和防篡改功能，广泛应用于区块链
 *
 * openzeppelin ECDSA，签名消息过程如下：
 *  1. 编码压缩消息：
 *    bytes memory packedMsg = abi.encodePacked(xx, yy, ...);
 *  2. 对编码后的消息取哈希：
 *    bytes32 msgHash = keccak256(packedMsg);
 *  3. 防止签名了可执行交易，这里二次加入特定字符串标识进行二次哈希：
 *    bytes32 msgEthHash = keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", msgHash));
 *  4. 用钱包私钥签名，例如在安装并登陆了账号的小狐狸钱包插件的浏览器 console 中输入：
 *    ethereum.enable()
 *    account = '你当前钱包的地址'
 *    hash = ‘第三步中的二次哈希值‘
 *    ethereum.request({method: "personal_sign", params: [account, hash]})
 *    // 在返回的结果中（Promise 的 PromiseResult）可以看到签名后的返回值
 *  5. 第三方可以根据上述的 msgEthHash 和签名后的信息，推导出 account 钱包地址，验证其身份
 *
 * 跟上一章 merkle tree 一样也可以用于白名单机制，例如授权某白名单 account Mint tokenId 的 NFT，
 * 授权方对上述信息进行哈希和签名，签名后的数据存储在服务器或发给用户，授权方只需在链上存储签名的钱包地址，
 * 用户 mint 时，输入自己的 account 钱包地址（链上可以获取 msg.sender）、对应的 tokenId（用户输入或服务器返回） 和
 * 数字签名（用户输入或服务器返回）。链上验证消息是否是授权方存储在链上的地址所签的名，即可判断该用户是否是白名单用户。
 *
 * 如果白名单在部署合约之前就确定了，默克尔树有优势，不需要私钥对每个数据进行签名。
 * 如果白名单更新比较频繁，那么签名验证比较有优势，因为默克尔树需要频繁改动链上的 Root Hash，比较费 gas
 */

import { ethers } from 'ethers';

// 注意公共节点可能不更新或失效
// https://chainlist.org/chain/11155111 可以替换最新的可以接口用来测试
const SEPOLIA_URL = 'https://eth-sepolia.api.onfinality.io/public';
const provider = new ethers.JsonRpcProvider(SEPOLIA_URL);

const mnemonic =
  'metal cereal clump disagree sight recall catch they fire diagram swallow nurse';
const hdNode = ethers.HDNodeWallet.fromPhrase(mnemonic);
const wallet = new ethers.Wallet(hdNode.privateKey, provider);
// address 0x3cf9a3265E00cfBda31bcFb90a11a684861d0E37
const signer = wallet.address;
console.log(`\n1. 签名钱包地址：${signer}`);
const account = '0x5B38Da6a701c568545dCfcB03FcB875f56beddC4';
const tokenId = '777';
console.log(
  `签名数据：address 0x5B38Da6a701c568545dCfcB03FcB875f56beddC4  uint256 777`
);
// 1. 签名钱包地址：0x3cf9a3265E00cfBda31bcFb90a11a684861d0E37
// 签名数据：address 0x5B38Da6a701c568545dCfcB03FcB875f56beddC4  uint256 777

// 第一次编码压缩后哈希消息
const msgHash = ethers.solidityPackedKeccak256(
  ['address', 'uint256'],
  [account, tokenId]
);
console.log(`\n2. 第一次编码压缩后哈希消息：${msgHash}`);
const messageHashBytes = ethers.getBytes(msgHash);
const msgEthHash = ethers.hashMessage(messageHashBytes);
console.log(`第二次哈希生成以太坊哈希：${msgEthHash}`);
// 2. 第一次编码压缩后哈希消息：0x9cbfc8400a2b7843453877d7ce881bdb4583fe33ab04019630bb68326671bc79
// 第二次哈希生成以太坊哈希：0x06e0e00d0c87ea36d1798f37553da2570fc0669c0aef614d840dc8f9c23f10c9

// 签名
const signature = wallet.signingKey.sign(msgEthHash).serialized;
// const signature = await wallet.signMessage(messageHashBytes); // 是上两步的简化
// 0xb0ad4d79e2a9712673e6b7be576665dea55ee47a265b6675f6d03919dfb8027d00a0714d6527a93fb1fa7289c10005ad7df57019d6bedeb7508c95e1cb1b35951c
console.log(`\n3. 签名：${signature}`);
// 3. 签名：0xb0ad4d79e2a9712673e6b7be576665dea55ee47a265b6675f6d03919dfb8027d00a0714d6527a93fb1fa7289c10005ad7df57019d6bedeb7508c95e1cb1b35951c

// 部署 sign 合约
const abi = [
  'function getMessageHash(address, uint256) public pure returns (bytes32)',
  'function toEthSignedMessageHash(bytes32) public pure returns (bytes32)',
  'function verify( bytes32, bytes memory, address) public pure returns (bool)',
];
// 合约字节码，在remix中，你可以在两个地方找到Bytecode
// i. 部署面板的 Bytecode 按钮
// ii. 文件面板 artifact 文件夹下与合约同名的 json 文件中
// 里面 "object" 字段对应的数据就是 Bytecode，挺长的，
// "object": "6080604052348015...
const bytecode =
  '6080604052348015600e575f80fd5b5061079e8061001c5f395ff3fe608060405234801561000f575f80fd5b506004361061003f575f3560e01c8063512c91df14610043578063823ac37314610073578063918a15cf146100a3575b5f80fd5b61005d600480360381019061005891906102ca565b6100d3565b60405161006a9190610320565b60405180910390f35b61008d6004803603810190610088919061049f565b610105565b60405161009a9190610525565b60405180910390f35b6100bd60048036038101906100b8919061053e565b610147565b6040516100ca9190610320565b60405180910390f35b5f82826040516020016100e79291906105ce565b60405160208183030381529060405280519060200120905092915050565b5f8173ffffffffffffffffffffffffffffffffffffffff166101278585610176565b73ffffffffffffffffffffffffffffffffffffffff161490509392505050565b5f81604051602001610159919061066d565b604051602081830303815290604052805190602001209050919050565b5f60418251146101bb576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016101b2906106ec565b60405180910390fd5b5f805f602085015192506040850151915060608501515f1a90506001868285856040515f81526020016040526040516101f79493929190610725565b6020604051602081039080840390855afa158015610217573d5f803e3d5ffd5b50505060206040510351935050505092915050565b5f604051905090565b5f80fd5b5f80fd5b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f6102668261023d565b9050919050565b6102768161025c565b8114610280575f80fd5b50565b5f813590506102918161026d565b92915050565b5f819050919050565b6102a981610297565b81146102b3575f80fd5b50565b5f813590506102c4816102a0565b92915050565b5f80604083850312156102e0576102df610235565b5b5f6102ed85828601610283565b92505060206102fe858286016102b6565b9150509250929050565b5f819050919050565b61031a81610308565b82525050565b5f6020820190506103335f830184610311565b92915050565b61034281610308565b811461034c575f80fd5b50565b5f8135905061035d81610339565b92915050565b5f80fd5b5f80fd5b5f601f19601f8301169050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b6103b18261036b565b810181811067ffffffffffffffff821117156103d0576103cf61037b565b5b80604052505050565b5f6103e261022c565b90506103ee82826103a8565b919050565b5f67ffffffffffffffff82111561040d5761040c61037b565b5b6104168261036b565b9050602081019050919050565b828183375f83830152505050565b5f61044361043e846103f3565b6103d9565b90508281526020810184848401111561045f5761045e610367565b5b61046a848285610423565b509392505050565b5f82601f83011261048657610485610363565b5b8135610496848260208601610431565b91505092915050565b5f805f606084860312156104b6576104b5610235565b5b5f6104c38682870161034f565b935050602084013567ffffffffffffffff8111156104e4576104e3610239565b5b6104f086828701610472565b925050604061050186828701610283565b9150509250925092565b5f8115159050919050565b61051f8161050b565b82525050565b5f6020820190506105385f830184610516565b92915050565b5f6020828403121561055357610552610235565b5b5f6105608482850161034f565b91505092915050565b5f8160601b9050919050565b5f61057f82610569565b9050919050565b5f61059082610575565b9050919050565b6105a86105a38261025c565b610586565b82525050565b5f819050919050565b6105c86105c382610297565b6105ae565b82525050565b5f6105d98285610597565b6014820191506105e982846105b7565b6020820191508190509392505050565b5f81905092915050565b7f19457468657265756d205369676e6564204d6573736167653a0a3332000000005f82015250565b5f610637601c836105f9565b915061064282610603565b601c82019050919050565b5f819050919050565b61066761066282610308565b61064d565b82525050565b5f6106778261062b565b91506106838284610656565b60208201915081905092915050565b5f82825260208201905092915050565b7f696e76616c6964207369676e6174757265206c656e67746800000000000000005f82015250565b5f6106d6601883610692565b91506106e1826106a2565b602082019050919050565b5f6020820190508181035f830152610703816106ca565b9050919050565b5f60ff82169050919050565b61071f8161070a565b82525050565b5f6080820190506107385f830187610311565b6107456020830186610716565b6107526040830185610311565b61075f6060830184610311565b9594505050505056fea26469706673582212200b5318d5b3f72ddbca47bf6e56524b728682ec2cef516d52d3bec8a05166033d64736f6c634300081a0033';
const factory = new ethers.ContractFactory(abi, bytecode, wallet);
const contract = await factory.deploy();
console.log(`\n4. 合约地址：${contract.target}`);
console.log('等待合约部署上链');
await contract.waitForDeployment();
console.log('合约已上链');
// 4. 合约地址：0x2e149D21381C4cb158807A6d0b250266f1fe35d7
// 等待合约部署上链
// 合约已上链

const _msgHash = await contract.getMessageHash(account, tokenId);
console.log(
  `\n5. 校验\n第一次 Hash 与链下计算的是否一致：${msgHash === _msgHash}`
);
const _msgEthHash = await contract.toEthSignedMessageHash(_msgHash);
console.log(`第二次 Hash 与链下计算的是否一致：${msgEthHash === _msgEthHash}`);
console.log(
  `验证签名消息签名人是否是 ${signer}：${await contract.verify(
    msgEthHash,
    signature,
    signer
  )}`
);
// 5. 校验
// 第一次 Hash 与链下计算的是否一致：true
// 第二次 Hash 与链下计算的是否一致：true
// 验证签名消息签名人是否是 0x3cf9a3265E00cfBda31bcFb90a11a684861d0E37：true
